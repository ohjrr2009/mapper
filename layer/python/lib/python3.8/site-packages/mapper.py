import airspeed
import json
import dirtyjson
import xmltodict
from lxml import etree
from enum import Enum
import xmlformatter
import time
from datetime import date, datetime, timezone, timedelta
from dateutil import parser
import re

# FUNÇÕES GENÉRICAS CUSTOMIZADAS
airspeed.__additional_methods__.get(str)["substring"] = lambda self, start, end: self[start:end]
airspeed.__additional_methods__.get(str)["contains"] = lambda self, text: text in self
airspeed.__additional_methods__.get(str)["convert_timezone"] = lambda self, from_tz, to_tz: \
    (parser.parse(self) +  timedelta(hours=to_tz-from_tz)).strftime("%Y-%m-%dT%H:%M:%S.%fZ")
airspeed.__additional_methods__.get(str)["get_date"] = lambda self, str_time: \
    parser.parse(self).strftime(str_time)

# FUNÇÕES CUSTOMIZADAS PARA O LETSBANK
airspeed.__additional_methods__.get(str)["get_key_type"] = lambda self: \
    check(self)

def check(chave) -> str:
    if "@" in chave:
        return "EMAIL"
    elif "+" in chave:
        return "PHONE"
    elif len(chave) == 11 and "+" not in chave:
        return "CPF"
    elif len(chave) == 14 and "+" not in chave:
        return "CNPJ"
    elif len(chave) > 14 and "-" in chave:
        return "EVP"
    else:
        return ""

class MapperType(Enum):
    JSON_TO_JSON = 1
    JSON_TO_XML = 2
    XML_TO_JSON = 3
    XML_TO_XML = 4

class InputOrigin(Enum):
    DEFAULT = 1
    AWS_EVENT = 2

class Mapper:
    default_macro = '''
        #macro(validate $input $type)
            #if($type == "string" && "$!input" != "")
                "$input"
            #elseif($type == "number" && "$!input" != "")
                $input
            #elseif($type == "boolean" && "$!input" != "")
                #if ("$input" == "False" || "$input" == "false")
                    false
                #elseif ("$input" == "True" || "$input" == "true")
                    true
                #end
            #elseif($type == "object" && "$!input" != "")
                $input
            #{else}
                null
            #end
        #end
    '''

    def __init__(self, type: MapperType, template: str, input: str, input_origin: InputOrigin = InputOrigin.DEFAULT, macros:list = []) -> None:
        self.type = type
        self.input_origin = input_origin

        for macro in macros:
            self.default_macro = self.default_macro + "\n" + macro

        self.template = airspeed.Template(self.default_macro + template)

        if self.type == MapperType.XML_TO_JSON or self.type == MapperType.XML_TO_XML:
            self.input = input
            if isinstance(self.input, str):
                self.input = str.encode(input.strip())

            self.input = etree.fromstring(self.input)
            self.input = etree.tostring(self.input, encoding='UTF-8', xml_declaration=False)
        else:
            self.input = input

        if input_origin == InputOrigin.AWS_EVENT:
            pass

    
    def map(self) -> str:
        inputRoot = {}
        inputHeaders = {}
        inputQueryStringParameters = {}
        inputPathParameters = {}
        inputBody = {}

        if self.type == MapperType.JSON_TO_XML or self.type == MapperType.JSON_TO_JSON:
            if self.input_origin == InputOrigin.DEFAULT:
                inputRoot = json.loads(self.input)
            elif self.input_origin == InputOrigin.AWS_EVENT:
                inputRoot = json.loads(self.input)
                inputHeaders = inputRoot.get("headers") if inputRoot.get("headers") != None else {}
                inputQueryStringParameters = inputRoot.get("queryStringParameters") if inputRoot.get("queryStringParameters") != None else {}
                inputPathParameters = inputRoot.get("pathParameters") if inputRoot.get("pathParameters") != None else {}
                inputBody = json.loads(inputRoot.get("body")) if inputRoot.get("body") != None else {}
        else:
            inputRoot = xmltodict.parse(self.input)

        if self.type == MapperType.JSON_TO_JSON:
            self.output = self.template.merge(locals())
            self.output = dirtyjson.loads(self.output)
            self.output = json.dumps(self.output, indent=4, ensure_ascii=False)
            
            return self.output
        elif self.type == MapperType.JSON_TO_XML:
            self.output = self.template.merge(locals())
            self.output = etree.fromstring(self.output)
            self.output = etree.tostring(self.output, encoding='UTF-8', xml_declaration=True, pretty_print=True).decode()
            
            formatter = xmlformatter.Formatter(indent="1", indent_char="\t", encoding_output="UTF-8", preserve=["literal"])
            self.output = formatter.format_string(self.output).decode()

            return self.output
        elif self.type == MapperType.XML_TO_JSON:
            self.output = self.template.merge(locals())
            self.output = dirtyjson.loads(self.output)
            self.output = json.dumps(self.output, indent=4, ensure_ascii=False)

            return self.output
        elif self.type == MapperType.XML_TO_XML:
            self.output = self.template.merge(locals())
            self.output = etree.fromstring(self.output)
            self.output = etree.tostring(self.output, encoding='UTF-8', xml_declaration=True, pretty_print=True).decode()
            
            formatter = xmlformatter.Formatter(indent="1", indent_char="\t", encoding_output="UTF-8", preserve=["literal"])
            self.output = formatter.format_string(self.output).decode()

            return self.output
